import os, json, nvdlib, time
from pebble import ProcessPool

import os.path, sys
sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), os.pardir))
import ag_model.NetworkModel as net
from generate_full_storage import generate_intentory
from generate_reachability import write_reachability
import config

"""
Generate the benchmark of networks inventories
"""
def generate_network(filename):
    if not os.path.exists(config.NETWORK_FOLDER): os.makedirs(config.NETWORK_FOLDER)
    generated_files = os.listdir(config.NETWORK_FOLDER)
    if filename not in generated_files:
        write_reachability(config.NETWORK_FOLDER,filename)

def generate_pancea_network(basename, devfile, vulnfile, reachfile):
    with open(devfile) as dev_f, open(vulnfile, encoding="utf8") as vuln_f, open(reachfile) as reach_f:
        devices = json.load(dev_f)["devices"]
        vulnerabilities = json.load(vuln_f)["vulnerabilities"]
        reachability = json.load(reach_f)["sourceDevices"]
    
    edges=[]
    for src in reachability:
        src_host = src["hostName"]
        src_id = src["id"]
        for iface in src["reachedInterface"]:
            for dst in iface["reachedDevices"]:
                dst_host = dst["hostName"]
                dst_id = dst["deviceId"]
                edges.append({"host_link": [src_host,dst_host], "id_link": [src_id,dst_id]})

    devices_inventory=[]
    for dev in devices:
        
        net_ifaces=[]
        for iface in dev["networkInterfaces"]:
            ipaddr = iface["ipAddress"]
            macaddr = iface["macAddress"]
            
            ports_netiface=[]
            for port_iface in iface["ports"]:
                portnum=port_iface["number"]
                portstate=port_iface["state"]
                portprotocol=port_iface["transportProtocol"]
                port_srv=net.Service(dev["hostName"], [], [])
                if port_iface["service"] != None:
                    cpe_srv = port_iface["service"]["cpe"]
                    vuln_srv = port_iface["service"]["vulnerabilities"]
                    port_srv = net.Service(dev["hostName"], cpe_srv, vuln_srv)
                
                ports_netiface.append(net.Port(portnum,portstate,portprotocol,port_srv))
            net_ifaces.append(net.NetworkInterface(ipaddr,macaddr,ports_netiface))
    
        os_sys = dev["operatingSystem"]
        if os_sys == None:
            devices_inventory.append({
                "id": dev["id"],
                "hostname": dev["hostName"],
                "type": dev["type"],
                "network_interfaces": net_ifaces,
                "local_applications":[]
            })
            continue
            
        services=[net.Service("operatingSystem", [os_sys["family"]+" "+os_sys["generation"]], os_sys["osVulnerabilities"])]
        for local_srv in os_sys["localServices"]:
            services.append(net.Service("application",local_srv["cpe"],local_srv["vulnerabilities"]))
        devices_inventory.append({
            "id": dev["id"],
            "hostname": dev["hostName"],
            "type": dev["type"],
            "network_interfaces": net_ifaces,
            "local_applications":[net.LocalApplication(os_sys["family"]+" "+os_sys["generation"]+" "+os_sys["vendor"],"app_name",services)]
        })
        

    vuln_inventory=[]
    for vuln in vulnerabilities:
        cve_nvd = nvdlib.searchCVE(cveId=vuln["cveId"])[0]
        vuln_inventory.append(cve_nvd)
        time.sleep(1)

    with open(basename, "w") as outfile:
        json_data = json.dumps({"devices":devices_inventory,
                                "vulnerabilities":vuln_inventory,"edges":edges},
                                default=lambda o: o.__dict__, indent=2)
        outfile.write(json_data)

if __name__ == "__main__":
    """
    To build the inventory from skratch
    NOTICE: this may require long time for NIST APIs. We suggest to use the 
    proposed syntetic inventory
    """
    # generate_intentory()

    """
    Create networks for reachability graphs
    """
    parameters = []
    filenames=[]
    for n in config.nhosts:
        for v in config.nvulns:
            for t in config.topologies:
                for d in config.distro:
                    for u in config.diversity:
                        filename = str(n)+'_'+str(v)+'_'+t+'_'+d+'_'+str(u)+'.json'
                        filenames.append(filename)

    """
    Generate Reachability Networks
    """
    # with ProcessPool(max_workers=config.num_cores) as pool:
    #     process = pool.map(generate_network, filenames)

    if not os.path.exists(config.NETWORK_FOLDER): os.makedirs(config.NETWORK_FOLDER)
    generated_files = []#os.listdir(config.NETWORK_FOLDER)
    if filename not in generated_files:
        write_reachability(config.NETWORK_FOLDER,filename)

    generate_pancea_network(config.real_inventory,config.panacea_device, config.panacea_vulnerabilities, config.panacea_reachability)