# Import lib
import json
import sys

from flask import Flask
from flask import request
from flask import jsonify

# Import subclasses
from filter import Filter
from aggregator import Aggregator



# REST server
app = Flask(__name__)



## CONTROLLER

# Root prints readme
@app.get("/")
def get_root():
    retval = "<html><head></head><body>"

    f = open("../README.md",encoding="utf-8")
    retval = retval + f.read()
    f.close()

    retval = retval.replace("\n","<br>")
    retval = retval + "</body></html>"

    return retval



# Post for one host
"""
This method applies aggregations and filters to one host
This method expects a json to be passed via the POST as input
This methods returns a json at the end of the computation

The input json should follow this structure:
input_json = {
                vulnerability_list = list(vulnerabilities in NVD CVE json format), #Use the same format as NVD
                host_cpe_inventory = list(list_of_cpe_in_the_host), #optional, required only if filter_mode > 0
                filter_mode = int, #0 means no action, 3 means strongest possible action
                aggregation_mode = int #0 means no action, 3 means strongest possible action
                }

The output json will follow this structure:
output_json = {
                equivalence_class_to_vulnerability_id = dict(key: unique class identifier; value: list(vulnerability identifier)), #Main output of the operation
                incompatible_vulnerability_list = list(vulnerability identifier), #Debug purposes, vulnerabilities filtered by the process, thus excluded from above
                filter_mode = int, #0 means no action, TBD means strongest possible action
                aggregation_mode = int #0 means no action, TBD means strongest possible action
                }
"""
@app.post("/host")
def post_single_host():
    # Get payload
    input_json = dict()
    if(request.is_json):
        input_json = request.get_json()
    else:
        return "No json has been passed!",400
    
    # Pass payload to filter subprocess
    vulnerability_list = input_json["vulnerability_list"]
    cpe_list = input_json["host_cpe_inventory"]

    # Perform Filter subprocess
    compatible_vulnerability_id_set,incompatible_vulnerability_id_set = Filter.perform(input_json["filter_mode"],vulnerability_list,cpe_list)

    # Prepare payload for aggregator subprocess
    compatible_vulnerability_list = list()
    for cve_struct in vulnerability_list:
        if cve_struct["cve"]["id"] in compatible_vulnerability_id_set:
            compatible_vulnerability_list.append(cve_struct)

    # Perform Aggregator subprocess
    aggregation_class_to_vulnerabilities = Aggregator.perform(input_json["aggregation_mode"],compatible_vulnerability_list)

    # Package return structure
    output_json = dict()
    output_json["equivalence_class_to_vulnerability_id"] = aggregation_class_to_vulnerabilities
    output_json["incompatible_vulnerability_list"] = list(incompatible_vulnerability_id_set)
    output_json["filter_mode"] = input_json["filter_mode"]
    output_json["aggregation_mode"] = input_json["aggregation_mode"]

    # Return
    return jsonify(output_json),200




# Per postare 

# import requests
# r = requests.post('http://localhost:10101/host', json={"key": "value"})