class Filter:
    # Constructor
    def __init__(self) -> None:
        pass



    # Service functions
    def sanitize_cpe(cpe,use_vendor,use_product,use_version):
        cpe = cpe[cpe.find(":")+1:]
        cpe = cpe[cpe.find(":")+1:]
        part = cpe[:cpe.find(":")]
        cpe = cpe[cpe.find(":")+1:]
        vendor = cpe[:cpe.find(":")]
        cpe = cpe[cpe.find(":")+1:]
        product = cpe[:cpe.find(":")]
        cpe = cpe[cpe.find(":")+1:]
        version = cpe[:cpe.find(":")]

        newcpe = part
        if (use_vendor==True):
            newcpe = newcpe+":"+vendor
        if (use_product==True):
            newcpe = newcpe+":"+product
        if (use_version==True):
            newcpe = newcpe+":"+version

        # CPE sanitization
        if "&" in newcpe:
            newcpe = newcpe.replace("&","")
        if "\\" in newcpe:
            newcpe = newcpe.replace("\\","")
        if "/" in newcpe:
            newcpe = newcpe.replace("/","")
            
        return newcpe
    


    def grab_cpe_tree(node,FILTER_CPE_VENDOR,FILTER_CPE_PRODUCT,FILTER_CPE_VERSION):
        print(node)

        local_cpe_set = set()
        
        if "operator" not in node:
            node["operator"] = "OR"
        
        if node["operator"] == "AND":
            # Grab all children
            if "nodes" in node:
                for child in node["nodes"]:
                    local_cpe_set.add(Filter.grab_cpe_tree(child,FILTER_CPE_VENDOR,FILTER_CPE_PRODUCT,FILTER_CPE_VERSION))
        
        else:
            # OR node
            # Grab all cpe
            if "cpeMatch" in node:
                for match in node["cpeMatch"]:
                    sanitized_cpe = Filter.sanitize_cpe(match["criteria"],FILTER_CPE_VENDOR,FILTER_CPE_PRODUCT,FILTER_CPE_VERSION)
                    # TODO Version ranges
                    if FILTER_CPE_VERSION == True:

                        cpe_version_str = ""
                        if ("versionEndExcluding" in match):
                            cpe_version_str = cpe_version_str + ";" + "< " + match["versionEndExcluding"]
                        elif ("versionEndIncluding" in match):
                            cpe_version_str = cpe_version_str + ";" + "<= " + match["versionEndIncluding"]
                        if ("versionStartIncluding" in match):
                            cpe_version_str = cpe_version_str + ";" + ">= " + match["versionStartIncluding"]
                        elif ("versionStartExcluding" in match):
                            cpe_version_str = cpe_version_str + ";" + "> " + match["versionStartExcluding"]
                    
                        cpe_version_str = cpe_version_str.replace(";","",1)

                        if cpe_version_str != "":
                            sanitized_cpe = sanitized_cpe[:sanitized_cpe.rfind(":")]
                            sanitized_cpe = sanitized_cpe + ":" + cpe_version_str

                    local_cpe_set.add(sanitized_cpe)

            # Grab all children
            if "nodes" in node:
                for child in node["nodes"]:
                    local_cpe_set = local_cpe_set.union(Filter.grab_cpe_tree(child,FILTER_CPE_VENDOR,FILTER_CPE_PRODUCT,FILTER_CPE_VERSION))
        
        return frozenset(local_cpe_set)
    


    def check_cpe_against_inventory(cpe,inventory):
        # TODO Version ranges
        return_value = False

        for inv_cpe in inventory:
            if cpe == inv_cpe:
                return_value = True
                break

        return return_value



    # Main function
    def perform(level,vulnerability_list,cpe_list):
        print("Performing filter operation [",level,"]")

        # Transform level to variables
        FILTER_CPE_VENDOR = False
        FILTER_CPE_PRODUCT = False
        FILTER_CPE_VERSION = False
        if level > 0: FILTER_CPE_VENDOR = True
        if level > 1: FILTER_CPE_PRODUCT = True
        if level > 2: FILTER_CPE_VERSION = True
        
        # Sanitize cpe_list
        sanitized_host_cpe_set = set()
        for cpe in cpe_list:
            sanitized_host_cpe_set.add(Filter.sanitize_cpe(cpe,FILTER_CPE_VENDOR,FILTER_CPE_PRODUCT,FILTER_CPE_VERSION))

        # Sanitize vulnerability_list
        sanitized_vulnerbaility_to_cpe_tree = dict()
        for cve_struct in vulnerability_list:
            cve_struct = cve_struct["cve"]

            sanitized_vulnerbaility_to_cpe_tree[cve_struct["id"]] = dict()
            if "configurations" in cve_struct:
                config_set = set()
                for config in cve_struct["configurations"]:
                    config_set = config_set.union(Filter.grab_cpe_tree(config,FILTER_CPE_VENDOR,FILTER_CPE_PRODUCT,FILTER_CPE_VERSION))
                
                normalized = False
                for elem in config_set:
                    if type(elem) == type(frozenset()):
                        normalized = True
                        break

                if normalized == False:
                    normalized_set = set()
                    normalized_set.add(frozenset(config_set))
                    config_set = normalized_set

                sanitized_vulnerbaility_to_cpe_tree[cve_struct["id"]] = config_set

        # Prepare output
        compatible_vulnerability_set = set()
        incompatible_vulnerability_set = set()

        # Apply filter logic
        for cve_id in sanitized_vulnerbaility_to_cpe_tree:
            and_satisfied = True
            for and_elem in sanitized_vulnerbaility_to_cpe_tree[cve_id]:
                or_satisfied = False
                for or_elem in and_elem:
                    if Filter.check_cpe_against_inventory(or_elem,sanitized_host_cpe_set) == True:
                        or_satisfied = True
                        break
                if or_satisfied == False:
                    and_satisfied = False
                    break
            
            if and_satisfied == True:
                compatible_vulnerability_set.add(cve_id)
            else:
                incompatible_vulnerability_set.add(cve_id)

        # Return output
        return compatible_vulnerability_set,incompatible_vulnerability_set


# Test
#"""
import requests

r = requests.get("https://services.nvd.nist.gov/rest/json/cves/2.0", params={"startIndex": str(1000), "resultsPerPage": str(2000)})
jsondata = r.json()
for cve in jsondata["vulnerabilities"]:
    print(cve["cve"]["id"])
compatible_vulnerability_set,incompatible_vulnerability_set = Filter.perform(3,jsondata["vulnerabilities"],list())
compatible_vulnerability_list = list(compatible_vulnerability_set)
sorted(compatible_vulnerability_list)
print(compatible_vulnerability_list)
incompatible_vulnerability_list = list(incompatible_vulnerability_set)
sorted(incompatible_vulnerability_list)
print(incompatible_vulnerability_list)
#"""