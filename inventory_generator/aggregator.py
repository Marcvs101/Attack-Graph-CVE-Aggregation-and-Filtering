class Aggregator:
    # Constructor
    def __init__(self) -> None:
        pass


    
    # CVSS tokenizer
    def tokenize_cvss(cvss3_string):
        cvss_str = dict()
        
        av = cvss3_string[:cvss3_string.find("/")]
        av = av.replace("AV:","")
        cvss3_string = cvss3_string[cvss3_string.find("/")+1:]

        ac = cvss3_string[:cvss3_string.find("/")]
        ac = ac.replace("AC:","")
        cvss3_string = cvss3_string[cvss3_string.find("/")+1:]

        pr = cvss3_string[:cvss3_string.find("/")]
        pr = pr.replace("PR:","")
        cvss3_string = cvss3_string[cvss3_string.find("/")+1:]

        ui = cvss3_string[:cvss3_string.find("/")]
        ui = ui.replace("UI:","")
        cvss3_string = cvss3_string[cvss3_string.find("/")+1:]

        s = cvss3_string[:cvss3_string.find("/")]
        s = s.replace("S:","")
        cvss3_string = cvss3_string[cvss3_string.find("/")+1:]

        c = cvss3_string[:cvss3_string.find("/")]
        c = c.replace("C:","")
        cvss3_string = cvss3_string[cvss3_string.find("/")+1:]

        i = cvss3_string[:cvss3_string.find("/")]
        i = i.replace("I:","")
        cvss3_string = cvss3_string[cvss3_string.find("/")+1:]

        a = cvss3_string[:cvss3_string.find("/")]
        a = a.replace("A:","")
        cvss3_string = cvss3_string[cvss3_string.find("/")+1:]

        cvss_str["AV"] = av
        cvss_str["AC"] = ac
        cvss_str["PR"] = pr
        cvss_str["UI"] = ui
        cvss_str["S"] = s
        cvss_str["C"] = c
        cvss_str["I"] = i
        cvss_str["A"] = a

        return cvss_str



    # CVSS converter
    def convert_cvss(cvss2):
        old_string = cvss2["vectorString"]

        old_av = old_string[:old_string.find("/")]
        old_av = old_av.replace("AV:","")
        old_string = old_string[old_string.find("/")+1:]

        old_ac = old_string[:old_string.find("/")]
        old_ac = old_ac.replace("AC:","")
        old_string = old_string[old_string.find("/")+1:]

        old_au = old_string[:old_string.find("/")]
        old_au = old_au.replace("Au:","")
        old_string = old_string[old_string.find("/")+1:]

        old_c = old_string[:old_string.find("/")]
        old_c = old_av.replace("C:","")
        old_string = old_string[old_string.find("/")+1:]

        old_i = old_string[:old_string.find("/")]
        old_i = old_av.replace("I:","")
        old_string = old_string[old_string.find("/")+1:]

        old_a = old_string
        old_a = old_av.replace("A:","")

        new_av = "N"
        if old_av == "A":
            new_av = "A"
        if old_av == "L":
            new_av = "L"

        new_ac = "H"
        new_ui = "R"
        if old_ac == "M":
            new_ac = "H"
            new_ui = "N"
        if old_ac == "L":
            new_ac = "L"
            new_ui = "N"

        new_pr = "N"
        if old_au == "S":
            new_pr = "L"
        if old_au == "M":
            new_pr = "H"

        new_c = "N"
        if old_c == "P":
            new_c = "L"
        if old_c == "C":
            new_c = "H"

        new_i = "N"
        if old_i == "P":
            new_i = "L"
        if old_i == "C":
            new_i = "H"

        new_a = "N"
        if old_a == "P":
            new_a = "L"
        if old_a == "C":
            new_a = "H"

        new_s = "U"
        if new_c == "H" and new_i == "H" and new_a == "H":
            new_s = "C"

        new_string = "AV:"+new_av+"/AC:"+new_ac+"/PR:"+new_pr+"/UI:"+new_ui+"/S:"+new_s+"/C:"+new_c+"/I:"+new_i+"/A:"+new_a
        return new_string


    # Aggregation by level
    # Level 0, don't do anything
    def no_aggregation(vulnerability_list):
        aggregation_class_to_vulnerabilities = dict()

        for cve_str in vulnerability_list:
            if cve_str["id"] not in aggregation_class_to_vulnerabilities:
                aggregation_class_to_vulnerabilities[cve_str["id"]] = dict()
            
            aggregation_class_to_vulnerabilities[cve_str["id"]]["vulnerability_id_list"] = list()
            aggregation_class_to_vulnerabilities[cve_str["id"]]["vulnerability_id_list"].append(cve_str["id"])

        return aggregation_class_to_vulnerabilities



    # Level 1, max compression
    def max_compression_aggregation(vulnerability_list):
        aggregation_class_to_vulnerabilities = dict()

        aggregation_class_to_vulnerabilities["unique"] = dict()
        aggregation_class_to_vulnerabilities["unique"]["vulnerability_id_list"] = list()
        for cve_str in vulnerability_list:
            aggregation_class_to_vulnerabilities["unique"]["vulnerability_id_list"].append(cve_str["id"])

        return aggregation_class_to_vulnerabilities



    # Level 3, max accuracy
    def max_accuracy_aggregation(vulnerability_list):
        aggregation_class_to_vulnerabilities = dict()

        for cve_str in vulnerability_list:

            # Merge all CVSS definitions into one
            bucket_identifier = ""

            for metric in cve_str["metrics"]:
                if metric == "cvssMetricV2":
                    # CVSS v2
                    for metric_str in cve_str["metrics"][metric]:
                        if metric_str["type"] == "Primary":
                            # Good to go
                            if bucket_identifier == "":
                                # Only consider v2 if no v3 is present
                                converted_str = Aggregator.convert_cvss(metric_str["cvssData"])

                                bucket_identifier = converted_str

                else:
                    # CVSS v3
                    for metric_str in cve_str["metrics"][metric]:
                        if metric_str["type"] == "Primary":
                            # Good to go
                            bucket_identifier = metric_str["cvssData"]["vectorString"][metric_str["cvssData"]["vectorString"].find("/")+1:]

            if bucket_identifier not in aggregation_class_to_vulnerabilities:
                aggregation_class_to_vulnerabilities[bucket_identifier] = dict()
                aggregation_class_to_vulnerabilities[bucket_identifier]["vulnerability_id_list"] = list()

            aggregation_class_to_vulnerabilities[bucket_identifier]["vulnerability_id_list"].append(cve_str["id"])


        return aggregation_class_to_vulnerabilities
    


    # Main function
    def perform(level,vulnerability_list):
        print("Performing aggregation operation [",level,"]")
        
        # Initialize return structure
        aggregation_class_to_vulnerabilities = dict()
        
        # Bucket vulnerabilities according to level
        if level == 0:
            # level 0, don't do anything
            aggregation_class_to_vulnerabilities = Aggregator.no_aggregation(vulnerability_list)
        elif level == 1:
            # Level 1, max compression
            aggregation_class_to_vulnerabilities = Aggregator.max_compression_aggregation(vulnerability_list)
        elif level == 2:
            # Level 2, in between
            pass
        else:
            # Level 3, max precision
            aggregation_class_to_vulnerabilities = Aggregator.max_accuracy_aggregation(vulnerability_list)

        # Return
        return aggregation_class_to_vulnerabilities
